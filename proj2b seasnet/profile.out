Total: 3540 samples
    3480  98.3%  98.3%     3539 100.0% manipulate_list_spin
      42   1.2%  99.5%       47   1.3% SortedList_lookup
      10   0.3%  99.8%       10   0.3% __strcmp_sse42
       7   0.2% 100.0%       12   0.3% SortedList_insert
       1   0.0% 100.0%        1   0.0% __munmap
       0   0.0% 100.0%     3539 100.0% __clone
       0   0.0% 100.0%        1   0.0% __deallocate_stack
       0   0.0% 100.0%        1   0.0% __free_stacks
       0   0.0% 100.0%        1   0.0% __libc_start_main
       0   0.0% 100.0%        1   0.0% _start
       0   0.0% 100.0%        1   0.0% main
       0   0.0% 100.0%        1   0.0% pthread_join
       0   0.0% 100.0%     3539 100.0% start_thread
ROUTINE ====================== manipulate_list_spin in /u/cs/ugrad/ege/CS111/proj2b/lab2_list.c
  3480   3539 Total samples (flat / cumulative)
     .      .   91:         }
     .      .   92:     }
     .      .   93:     return NULL;
     .      .   94: }
     .      .   95: 
---
     .      .   96: void* manipulate_list_spin(void *arg) {
     .      .   97:     SortedListElement_t *start = arg;
     .      .   98:     int i;
     .      .   99:     for (i = 0; i < num_iterations; i++) {
  1638   1638  100:         while (__sync_lock_test_and_set(&lock_spin, 1) == 1) {
     .      .  101:             ; //spin
     .      .  102:         }
     .     12  103:         SortedList_insert(list, start + i);
     .      .  104:         __sync_lock_release(&lock_spin);
     .      .  105:     }
     1      1  106:     while (__sync_lock_test_and_set(&lock_spin, 1) == 1) {
     .      .  107:         ; //spin
     .      .  108:     }
     .      .  109:     int length = SortedList_length(list);
     .      .  110:     __sync_lock_release(&lock_spin);
     .      .  111:     if (length == -1) {
     .      .  112:         fprintf(stderr, "List corrupted after insertion");
     .      .  113:         exit(2);
     .      .  114:     }
     .      .  115:     for (i = 0; i < num_iterations; i++) {
  1841   1841  116:         while (__sync_lock_test_and_set(&lock_spin, 1) == 1) {
     .      .  117:             ; //spin
     .      .  118:         }
     .     47  119:         SortedListElement_t* search_result = SortedList_lookup(list, start[i].key);
     .      .  120:         if (search_result == NULL) {
     .      .  121:             fprintf(stderr, "List corrupted when looking for inserted element");
     .      .  122:             exit(2);
     .      .  123:         }
     .      .  124:         int delete_ret = SortedList_delete(search_result);
     .      .  125:         __sync_lock_release(&lock_spin);
     .      .  126:         if (delete_ret == 1) {
     .      .  127:             fprintf(stderr, "List corrupted while deletion");
     .      .  128:             exit(2);
     .      .  129:         }
     .      .  130:     }
     .      .  131:     return NULL;
     .      .  132: }
---
     .      .  133: 
     .      .  134: 
     .      .  135: typedef enum locks {
     .      .  136:     none, mutex, spin
     .      .  137: } lock_type;
ROUTINE ====================== manipulate_list_spin in /u/cs/ugrad/ege/CS111/proj2b/lab2_list.c
  3480   3539 Total samples (flat / cumulative)
     .      .   91:         }
     .      .   92:     }
     .      .   93:     return NULL;
     .      .   94: }
     .      .   95: 
---
     .      .   96: void* manipulate_list_spin(void *arg) {
     .      .   97:     SortedListElement_t *start = arg;
     .      .   98:     int i;
     .      .   99:     for (i = 0; i < num_iterations; i++) {
  1638   1638  100:         while (__sync_lock_test_and_set(&lock_spin, 1) == 1) {
     .      .  101:             ; //spin
     .      .  102:         }
     .     12  103:         SortedList_insert(list, start + i);
     .      .  104:         __sync_lock_release(&lock_spin);
     .      .  105:     }
     1      1  106:     while (__sync_lock_test_and_set(&lock_spin, 1) == 1) {
     .      .  107:         ; //spin
     .      .  108:     }
     .      .  109:     int length = SortedList_length(list);
     .      .  110:     __sync_lock_release(&lock_spin);
     .      .  111:     if (length == -1) {
     .      .  112:         fprintf(stderr, "List corrupted after insertion");
     .      .  113:         exit(2);
     .      .  114:     }
     .      .  115:     for (i = 0; i < num_iterations; i++) {
  1841   1841  116:         while (__sync_lock_test_and_set(&lock_spin, 1) == 1) {
     .      .  117:             ; //spin
     .      .  118:         }
     .     47  119:         SortedListElement_t* search_result = SortedList_lookup(list, start[i].key);
     .      .  120:         if (search_result == NULL) {
     .      .  121:             fprintf(stderr, "List corrupted when looking for inserted element");
     .      .  122:             exit(2);
     .      .  123:         }
     .      .  124:         int delete_ret = SortedList_delete(search_result);
     .      .  125:         __sync_lock_release(&lock_spin);
     .      .  126:         if (delete_ret == 1) {
     .      .  127:             fprintf(stderr, "List corrupted while deletion");
     .      .  128:             exit(2);
     .      .  129:         }
     .      .  130:     }
     .      .  131:     return NULL;
     .      .  132: }
---
     .      .  133: 
     .      .  134: 
     .      .  135: typedef enum locks {
     .      .  136:     none, mutex, spin
     .      .  137: } lock_type;
